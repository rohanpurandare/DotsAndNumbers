<!--Code snippets from Mt. Ford Studios-->
<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <link rel="shortcut icon" type="image/png" href="images/fav.png"/>
    <link rel="stylesheet" href="styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Quicksand&display=swap" rel="stylesheet">
    <title>Dots and Boxes</title>
    <style></style>
</head>

<body>
    <div>
            <button class="button button1" type="button" onclick=clearLines()>Clear Lines!</button>
            <button class="button button1" onclick="{newGame()}">New Game!</button>
            <button class="button button1" onclick="location.href='howto.html'">How to Play!</button>
            <div id="div">
                <img src="/images/music-message.png" width = 400>
            </div>
    </div>
    <br>
    <script>
        var keepPlaying = true;

        // game parameters
        const DELAY_END = 4; // seconds until a new game starts
        const FPS = 30; // frames per second
        const GRID_SIZE = 5; // number of rows (and columns)
        var height, width;
        if (window.innerHeight - 120 < window.innerWidth) {
            height = window.innerHeight - 120;
            width = height * .9;
        } else {
            width = window.innerWidth - 15;
            height = width * (1 / 0.9);
        }
        const HEIGHT = height; // pixels

        // derived dimensions
        const WIDTH = width;
        const CELL = WIDTH / (GRID_SIZE + 2); // size of cells (as well as left and right margin)
        const STROKE = CELL / 12; // stroke width
        const DOT = STROKE; // dot radius
        const MARGIN = HEIGHT - (GRID_SIZE + 1) * CELL; // top margin for score, names, etc.

        // colours
        const COLOR_BOARD = "#adf7ff";
        const COLOR_BORDER = "dimgrey";
        const LIGHT_GREY = "lightgrey";
        const COLOR_DOT = "black";
        const COLOR_PLAY = "dimgrey";
        const COLOR_PLAY_LIT = "lightpink";
        const GREEN = "lightgreen";
        // text
        const TEXT_SIZE_CELL = CELL / 3;
        const TEXT_SIZE_TOP = MARGIN / 6;
        const TEXT_WIN = "YOU WIN!";


        // definitions
        const Side = {
            BOT: 0,
            LEFT: 1,
            TOP: 2,
            RIGHT: 3
        }

        var greenCounter, winner, lines, squareCounter, loopTimer, gameTimer, stringTime;
        var gameNumber = parseInt(Math.random() * 12);
        window.setTimeout("closeDiv();", 5000);

        function closeDiv(){
            document.getElementById("div").style.display=" none";
        }
        
        var lineAnswer = new Array(GRID_SIZE * 2 * (GRID_SIZE + 1)).fill(0);
        var neighbors = [];
        var complete = false;
        const minLength = GRID_SIZE * 4;
        var backTrack = false;

        //0 = not in loop, 1 = in loop, 2 = can not be in loop, 3 = initial neighbors
        function generateLines() {
            var flag = 0;
            var stack = new Array(GRID_SIZE * 2 * (GRID_SIZE + 1)).fill(0);
            var stackCounter = 0;
            var startPoint = parseInt(Math.random() * GRID_SIZE * 2 * (GRID_SIZE + 1));
            stack[stackCounter] = startPoint;
            var current;
            var counter = 0;
            while (!complete) { //add condition
                current = stack[stackCounter];
                stackCounter++;
                lineAnswer[current] = 1;
                console.log("current ", current);
                neighbors = [];
                findNeighbors(current, minLength, stackCounter);
                if (neighbors.length == 0) { //need to backtrack
                    lineAnswer[current] = 4;
                    stackCounter--;
                    stack[stackCounter] = 0;
                    stackCounter--;
                    backTrack = true;
                }
                else {
                    backTrack = false;
                    var newIndex = chooseNeighbor(stackCounter);
                    if (flag == 0) {
                        updateNeighbors(newIndex, 3);
                        flag = 1;
                    }
                    else {
                        updateNeighbors(newIndex, 2)
                    }
                    stack[stackCounter] = neighbors[newIndex];
                    console.log(neighbors.length);
                    console.log(current, neighbors);
                    counter++;
                    if (counter == 15) {
                        complete = true;
                    }
                    console.log(stack);
                }
            }
        }

        function updateNeighbors(newIndex, key) {
            for (var i = 0; i < neighbors.length; i++) {
                lineAnswer[neighbors[i]] = key;
            }
            lineAnswer[neighbors[newIndex]] = 1;
        }

        function chooseNeighbor(stackCounter) {
            for (var i = 0; i < neighbors.length; i++) {
                if (lineAnswer[neighbors[i]] == 3 && stackCounter > minLength) {
                    complete = true;
                    return i;
                }
            }
            return parseInt(Math.random() * neighbors.length)
        }

        function findNeighbors(current, stackCounter) {
            var arrayCounter = 0;
            console.log("horizontal:")
            if (current < (GRID_SIZE * (GRID_SIZE + 1))) { //horizontal
                //  | |
                // - ~ - you are squigly
                //  | |
                if ((current - 1) % GRID_SIZE < GRID_SIZE - 1) { //left h
                    console.log("    left ", current - 1);
                    if (lineAnswer[current - 1] == 0) {
                        neighbors[arrayCounter] = current - 1;
                        arrayCounter++;
                    }
                    if (lineAnswer[current - 1] == 3 && minLength < stackCounter) {
                        neighbors[arrayCounter] = current - 1;
                        arrayCounter++;
                    }
                    if (lineAnswer[current - 1] == 2 && backTrack) {
                        neighbors[arrayCounter] = current - 1;
                        arrayCounter++;
                    }
                }
                if ((current + 1) % GRID_SIZE > 0) { //right h
                    console.log("    right ", current + 1);
                    if (lineAnswer[current + 1] == 0) {
                        neighbors[arrayCounter] = current + 1;
                        arrayCounter++;
                    }
                    if (lineAnswer[current + 1] ==  3 && minLength < stackCounter) {
                        neighbors[arrayCounter] = current + 1;
                        arrayCounter++;
                    }
                    if (lineAnswer[current + 1] ==  2 && backTrack) {
                        neighbors[arrayCounter] = current + 1;
                        arrayCounter++;
                    }
                }
                console.log("formula ", ((current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + parseInt(current / GRID_SIZE)));
                if (((current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + parseInt(current / GRID_SIZE)) < (current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + GRID_SIZE) { //bottom left v
                    console.log("    bottom left", ((current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + parseInt(current / GRID_SIZE)));
                    if (lineAnswer[(current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + parseInt(current / GRID_SIZE)] == 0) {
                        neighbors[arrayCounter] = (current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + parseInt(current / GRID_SIZE);
                        arrayCounter++;
                    }
                    if (lineAnswer[(current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + parseInt(current / GRID_SIZE)] == 3 && minLength < stackCounter) {
                        neighbors[arrayCounter] = (current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + parseInt(current / GRID_SIZE);
                        arrayCounter++;
                    }
                    if (lineAnswer[(current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + parseInt(current / GRID_SIZE)] == 2 && backTrack) {
                        neighbors[arrayCounter] = (current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + parseInt(current / GRID_SIZE);
                        arrayCounter++;
                    }
                }
                console.log("p ", ((current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + parseInt(current / GRID_SIZE) - 1));
                if (((current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + parseInt(current / GRID_SIZE) - 1) >= ((current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)))) { //top left v
                    console.log("    top left", ((current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + parseInt(current / GRID_SIZE) - 1));
                    if (lineAnswer[(current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + parseInt(current / GRID_SIZE) - 1] == 0) {
                        neighbors[arrayCounter] = (current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + parseInt(current / GRID_SIZE) - 1;
                        arrayCounter++;
                    }
                    if (lineAnswer[(current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + parseInt(current / GRID_SIZE) - 1] == 3 && minLength < stackCounter) {
                        neighbors[arrayCounter] = (current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + parseInt(current / GRID_SIZE) - 1;
                        arrayCounter++;
                    }
                    if (lineAnswer[(current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + parseInt(current / GRID_SIZE) - 1] == 2 && backTrack) {
                        neighbors[arrayCounter] = (current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + parseInt(current / GRID_SIZE) - 1;
                        arrayCounter++;
                    }
                }
                if (((current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + parseInt(current / GRID_SIZE) + GRID_SIZE) < (current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + (2 * GRID_SIZE)) { //bottom right v
                    console.log("    bottom right", ((current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + parseInt(current / GRID_SIZE) + GRID_SIZE));
                    if (lineAnswer[(current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + parseInt(current / GRID_SIZE) + GRID_SIZE] == 0) {
                        neighbors[arrayCounter] = (current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + parseInt(current / GRID_SIZE) + GRID_SIZE;
                        arrayCounter++;
                    }
                    if (lineAnswer[(current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + parseInt(current / GRID_SIZE) + GRID_SIZE] == 3 && minLength < stackCounter) {
                        neighbors[arrayCounter] = (current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + parseInt(current / GRID_SIZE) + GRID_SIZE;
                        arrayCounter++;
                    }
                    if (lineAnswer[(current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + parseInt(current / GRID_SIZE) + GRID_SIZE] == 2 && backTrack) {
                        neighbors[arrayCounter] = (current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + parseInt(current / GRID_SIZE) + GRID_SIZE;
                        arrayCounter++;
                    }
                }
                if (((current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + parseInt(current / GRID_SIZE) + GRID_SIZE - 1) >= (current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + GRID_SIZE) { //top right v
                    console.log("    top right", ((current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + parseInt(current / GRID_SIZE) + GRID_SIZE - 1));
                    if (lineAnswer[(current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + parseInt(current / GRID_SIZE) + GRID_SIZE - 1] == 0) {
                        neighbors[arrayCounter] = (current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + parseInt(current / GRID_SIZE) + GRID_SIZE - 1;
                        arrayCounter++;
                    }
                    if (lineAnswer[(current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + parseInt(current / GRID_SIZE) + GRID_SIZE - 1] == 3 && minLength < stackCounter) {
                        neighbors[arrayCounter] = (current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + parseInt(current / GRID_SIZE) + GRID_SIZE - 1;
                        arrayCounter++;
                    }
                    if (lineAnswer[(current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + parseInt(current / GRID_SIZE) + GRID_SIZE - 1] == 2 && backTrack) {
                        neighbors[arrayCounter] = (current % GRID_SIZE) * GRID_SIZE + (GRID_SIZE * (GRID_SIZE + 1)) + parseInt(current / GRID_SIZE) + GRID_SIZE - 1;
                        arrayCounter++;
                    }
                }
            }
            else { //vertical
                //  |
                // - -
                //  $  <-- you are dollar sign
                // - -
                //  |
                console.log("vertical:");
                if ((current - 1) % GRID_SIZE < GRID_SIZE - 1) { //top
                    console.log("    top ", current - 1);
                    if (lineAnswer[current - 1] == 0) {
                        neighbors[arrayCounter] = current - 1;
                        arrayCounter++;
                    }
                    if (lineAnswer[current - 1] == 3 && minLength < stackCounter) {
                        neighbors[arrayCounter] = current - 1;
                        arrayCounter++;
                    }
                    if (lineAnswer[current - 1] == 2 && backTrack) {
                        neighbors[arrayCounter] = current - 1;
                        arrayCounter++;
                    }
                }
                if ((current + 1) % GRID_SIZE > 0) { //bottom v
                    console.log("    bottom ", current + 1);
                    if (lineAnswer[current + 1] == 0) {
                        neighbors[arrayCounter] = current + 1;
                        arrayCounter++;
                    }
                    if (lineAnswer[current + 1] == 3 && minLength < stackCounter) {
                        neighbors[arrayCounter] = current + 1;
                        arrayCounter++;
                    }
                    if (lineAnswer[current + 1] == 2 && backTrack) {
                        neighbors[arrayCounter] = current + 1;
                        arrayCounter++;
                    }
                }
                if ((current % GRID_SIZE) * GRID_SIZE + parseInt((current - (GRID_SIZE * (GRID_SIZE + 1))) / GRID_SIZE) < (current % GRID_SIZE) * GRID_SIZE + GRID_SIZE) { //top right h
                    console.log("    top right ", (current % GRID_SIZE) * GRID_SIZE + parseInt((current - (GRID_SIZE * (GRID_SIZE + 1))) / GRID_SIZE));
                    if (lineAnswer[(current % GRID_SIZE) * GRID_SIZE + parseInt((current - (GRID_SIZE * (GRID_SIZE + 1))) / GRID_SIZE)] == 0) {
                        neighbors[arrayCounter] = (current % GRID_SIZE) * GRID_SIZE + parseInt((current - (GRID_SIZE * (GRID_SIZE + 1))) / GRID_SIZE);
                        arrayCounter++;
                    }
                    if (lineAnswer[(current % GRID_SIZE) * GRID_SIZE + parseInt((current - (GRID_SIZE * (GRID_SIZE + 1))) / GRID_SIZE)] == 3 && minLength < stackCounter) {
                        neighbors[arrayCounter] = (current % GRID_SIZE) * GRID_SIZE + parseInt((current - (GRID_SIZE * (GRID_SIZE + 1))) / GRID_SIZE);
                        arrayCounter++;
                    }
                    if (lineAnswer[(current % GRID_SIZE) * GRID_SIZE + parseInt((current - (GRID_SIZE * (GRID_SIZE + 1))) / GRID_SIZE)] == 2 && backTrack) {
                        neighbors[arrayCounter] = (current % GRID_SIZE) * GRID_SIZE + parseInt((current - (GRID_SIZE * (GRID_SIZE + 1))) / GRID_SIZE);
                        arrayCounter++;
                    }
                }
                if (((current % GRID_SIZE) * GRID_SIZE + parseInt((current - (GRID_SIZE * (GRID_SIZE + 1))) / GRID_SIZE) - 1) >= (current % GRID_SIZE) * GRID_SIZE) { //top left h
                    console.log("   top left ", ((current % GRID_SIZE) * GRID_SIZE + parseInt((current - (GRID_SIZE * (GRID_SIZE + 1))) / GRID_SIZE) - 1));
                    if (lineAnswer[((current % GRID_SIZE) * GRID_SIZE + parseInt((current - (GRID_SIZE * (GRID_SIZE + 1))) / GRID_SIZE) - 1)] == 0) {
                        neighbors[arrayCounter] = ((current % GRID_SIZE) * GRID_SIZE + parseInt((current - (GRID_SIZE * (GRID_SIZE + 1))) / GRID_SIZE) - 1);
                        arrayCounter++;
                    }
                    if (lineAnswer[((current % GRID_SIZE) * GRID_SIZE + parseInt((current - (GRID_SIZE * (GRID_SIZE + 1))) / GRID_SIZE) - 1)] == 3 && minLength < stackCounter) {
                        neighbors[arrayCounter] = ((current % GRID_SIZE) * GRID_SIZE + parseInt((current - (GRID_SIZE * (GRID_SIZE + 1))) / GRID_SIZE) - 1);
                        arrayCounter++;
                    }
                    if (lineAnswer[((current % GRID_SIZE) * GRID_SIZE + parseInt((current - (GRID_SIZE * (GRID_SIZE + 1))) / GRID_SIZE) - 1)] == 2 && backTrack) {
                        neighbors[arrayCounter] = ((current % GRID_SIZE) * GRID_SIZE + parseInt((current - (GRID_SIZE * (GRID_SIZE + 1))) / GRID_SIZE) - 1);
                        arrayCounter++;
                    }
                }
                if (((current % GRID_SIZE) * GRID_SIZE + parseInt((current - (GRID_SIZE * (GRID_SIZE + 1))) / GRID_SIZE) + GRID_SIZE) < (2 + (current % GRID_SIZE)) * GRID_SIZE) { //bottom right h
                    console.log("   bottom right ", ((current % GRID_SIZE) * GRID_SIZE + parseInt((current - (GRID_SIZE * (GRID_SIZE + 1))) / GRID_SIZE) + GRID_SIZE));
                    if (lineAnswer[(current % GRID_SIZE) * GRID_SIZE + parseInt((current - (GRID_SIZE * (GRID_SIZE + 1))) / GRID_SIZE) + GRID_SIZE] == 0) {
                        neighbors[arrayCounter] = (current % GRID_SIZE) * GRID_SIZE + parseInt((current - (GRID_SIZE * (GRID_SIZE + 1))) / GRID_SIZE) + GRID_SIZE; 
                        arrayCounter++;
                    }
                    if (lineAnswer[(current % GRID_SIZE) * GRID_SIZE + parseInt((current - (GRID_SIZE * (GRID_SIZE + 1))) / GRID_SIZE) + GRID_SIZE] == 3 && minLength < stackCounter) {
                        neighbors[arrayCounter] = (current % GRID_SIZE) * GRID_SIZE + parseInt((current - (GRID_SIZE * (GRID_SIZE + 1))) / GRID_SIZE) + GRID_SIZE; 
                        arrayCounter++;
                    }
                    if (lineAnswer[(current % GRID_SIZE) * GRID_SIZE + parseInt((current - (GRID_SIZE * (GRID_SIZE + 1))) / GRID_SIZE) + GRID_SIZE] == 2 && backTrack) {
                        neighbors[arrayCounter] = (current % GRID_SIZE) * GRID_SIZE + parseInt((current - (GRID_SIZE * (GRID_SIZE + 1))) / GRID_SIZE) + GRID_SIZE; 
                        arrayCounter++;
                    }
                }
                console.log(((current % GRID_SIZE) * GRID_SIZE + parseInt((current - (GRID_SIZE * (GRID_SIZE + 1))) / GRID_SIZE) + GRID_SIZE - 1), "!!!", (current % GRID_SIZE) * GRID_SIZE + GRID_SIZE)
                if (((current % GRID_SIZE) * GRID_SIZE + parseInt((current - (GRID_SIZE * (GRID_SIZE + 1))) / GRID_SIZE) + GRID_SIZE - 1) >= (current % GRID_SIZE) * GRID_SIZE + GRID_SIZE) { //bottom left h
                    console.log("   bottom left ", ((current % GRID_SIZE) * GRID_SIZE + parseInt((current - (GRID_SIZE * (GRID_SIZE + 1))) / GRID_SIZE) + GRID_SIZE - 1));
                    if (lineAnswer[((current % GRID_SIZE) * GRID_SIZE + parseInt((current - (GRID_SIZE * (GRID_SIZE + 1))) / GRID_SIZE) + GRID_SIZE - 1)] == 0) {
                        neighbors[arrayCounter] = ((current % GRID_SIZE) * GRID_SIZE + parseInt((current - (GRID_SIZE * (GRID_SIZE + 1))) / GRID_SIZE) + GRID_SIZE - 1);
                        arrayCounter++;
                    }
                    if (lineAnswer[((current % GRID_SIZE) * GRID_SIZE + parseInt((current - (GRID_SIZE * (GRID_SIZE + 1))) / GRID_SIZE) + GRID_SIZE - 1)] == 3 && minLength < stackCounter) {
                        neighbors[arrayCounter] = ((current % GRID_SIZE) * GRID_SIZE + parseInt((current - (GRID_SIZE * (GRID_SIZE + 1))) / GRID_SIZE) + GRID_SIZE - 1);
                        arrayCounter++;
                    }
                    if (lineAnswer[((current % GRID_SIZE) * GRID_SIZE + parseInt((current - (GRID_SIZE * (GRID_SIZE + 1))) / GRID_SIZE) + GRID_SIZE - 1)] == 2 && backTrack) {
                        neighbors[arrayCounter] = ((current % GRID_SIZE) * GRID_SIZE + parseInt((current - (GRID_SIZE * (GRID_SIZE + 1))) / GRID_SIZE) + GRID_SIZE - 1);
                        arrayCounter++;
                    }
                }
            }
        }

        const linesAnswer = [
            [0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0],
            [0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1],
            [0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0],
            [1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0],
            [0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
            [0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0],
            [0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0],
            [0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0],
            [0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0]
        ];
        const initialValues = [
            [0, 1, 3, 2, 0, 1, 2, 1, 2, 2, 3, 2, 0, 0, 2, 1, 3, 1, 0, 2, 1, 3, 1, 2, 2],
            [1, 3, 1, 1, 1, 2, 2, 2, 2, 3, 2, 1, 3, 2, 2, 2, 1, 2, 1, 1, 1, 1, 2, 3, 1],
            [1, 0, 0, 1, 0, 3, 2, 2, 3, 1, 1, 2, 2, 2, 1, 2, 2, 1, 1, 0, 3, 1, 0, 0, 0],
            [0, 2, 2, 1, 2, 1, 2, 0, 1, 2, 1, 1, 2, 2, 1, 1, 2, 3, 1, 1, 1, 2, 2, 2, 3],
            [1, 2, 3, 2 ,1, 3, 1, 0, 1, 3, 2, 1, 0, 1, 2, 1, 2, 0, 2, 1, 0, 2, 3, 2, 0],
            [3, 1, 1, 2, 2, 2, 1, 0, 0, 3, 1, 2, 1, 1, 2, 0, 1, 2, 2, 1, 0, 0, 1, 3, 1],
            [1, 3, 1, 2, 3, 0, 3, 2, 2, 1, 2, 2, 1, 2, 0, 3, 1, 0, 2, 1, 1, 2, 2, 2, 1],
            [0, 1, 3, 3, 3, 1, 2, 1, 1, 1, 3, 1, 0, 0, 1, 2, 1, 0, 1, 2, 1, 2, 2, 2, 1],
            [1, 3, 2, 3, 3, 1, 3, 1, 2, 2, 2, 1, 1, 3, 1, 2, 1, 0, 2, 1, 1, 2, 2, 2, 1],
            [1, 0, 1, 1, 1, 3, 3, 2, 1, 2, 1, 2, 1, 0, 2, 2, 2, 2, 2, 2, 3, 1, 1, 3, 1],
            [2, 3, 2, 2, 2, 2, 2, 2, 1, 1, 2, 2, 2, 1, 1, 2, 3, 2, 0, 2, 2, 2, 1, 2, 2]
        ];

        // set up the game canvas
        var canv = document.createElement("canvas");
        canv.height = HEIGHT;
        canv.width = WIDTH;
        document.body.appendChild(canv);
        var canvRect = canv.getBoundingClientRect();

        // set up the context
        var ctx = canv.getContext("2d");
        ctx.lineWidth = STROKE;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        // game variables
        var currentCells, squares;
        var scoreComp, scorePlay;
        var timeEnd;

        // start a new game
        newGame();

        // event handlers
        canv.addEventListener("mousemove", highlightGrid);
        canv.addEventListener("click", click);

        // set up the game loop
        setInterval(loop, 1000 / FPS);

        function loop() {
            drawBoard();
            if (keepPlaying) {
                drawSquares();
                drawGrid();
                drawScores();
            }
            //drawNewLines();
        }

        function clearLines() {
            if(timeEnd == 0) {
                for (let i = 0; i < GRID_SIZE; i++) {
                    for (let j = 0; j < GRID_SIZE; j++) {
                        squares[i][j].clearLines();
                    }
                }
            }
        }

        function click(/** @type {MouseEvent} */ ev) {
            if (/*TODO !playersTurn ||*/ timeEnd > 0) {
                return;
            }
            selectSide();
        }

        function drawBoard() {
            ctx.fillStyle = COLOR_BOARD;
            ctx.strokeStyle = COLOR_BORDER;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            ctx.strokeRect(STROKE / 2, STROKE / 2, WIDTH - STROKE, HEIGHT - STROKE);
        }

        function drawDot(x, y) {
            ctx.fillStyle = COLOR_DOT;
            ctx.beginPath();
            ctx.arc(x, y, DOT, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawGrid() {
            for (let i = 0; i < GRID_SIZE + 1; i++) {
                for (let j = 0; j < GRID_SIZE + 1; j++) {
                    drawDot(getGridX(j), getGridY(i));
                }
            }
            //Draw lines
        }

        function drawTimer(done) {
            if (!done) {
                loopTimer++;
                if (loopTimer % FPS == 0) { //goes inside every second
                    gameTimer++;
                    stringTime = Math.floor(gameTimer/60).toString().padStart(2, '0') + ":" + (gameTimer%60).toString().padStart(2, '0');
                    //console.log(stringTime);
                }
            }
            drawText(stringTime, WIDTH * 0.5, MARGIN * 0.5, COLOR_PLAY, TEXT_SIZE_TOP); //this draws 30 times per second
        }

        function drawLine(x0, y0, x1, y1, color) {
            ctx.strokeStyle = color;
            ctx.beginPath();
            ctx.moveTo(x0, y0);
            ctx.lineTo(x1, y1);
            ctx.stroke();
        }

        function drawScores() {
            if (winner) {
                drawTimer(false);
                //console.log(greenCounter);
                if (greenCounter == (GRID_SIZE * GRID_SIZE)) {
                    var output = true;
                    for (var i = 0; i < GRID_SIZE * GRID_SIZE + GRID_SIZE; i++) {
                        if (lines[i] != linesAnswer[gameNumber][i]) {
                            output = false;
                        }
                        if (lines[i + 30] != linesAnswer[gameNumber][i + 30]) {
                            output = false;
                        }
                    }
                    if (output) {
                        timeEnd = 1;
                        winner = false;
                    }
                }
            } else {
                drawTimer(true);
            }
            if (timeEnd > 0) {
                drawText(TEXT_WIN, WIDTH * 0.5, MARGIN * 0.7, COLOR_PLAY, TEXT_SIZE_TOP);
            }
        }

        function drawSquares() {
            for (let row of squares) {
                for (let square of row) {
                    square.drawSides();
                    square.drawFill();
                }
            }
        }

        function drawText(text, x, y, color, size) {
            ctx.fillStyle = color;
            ctx.font = size + "px dejavu sans mono";
            ctx.fillText(text, x, y);
        }

        function getColor(light) {
            return light ? LIGHT_GREY : COLOR_PLAY;
        }

        function getColorCopy(light) {
            return light ? GREEN : COLOR_PLAY_LIT;
        }

        function getText(value, small) {
            return value;
        }

        function getGridX(col) {
            return CELL * (col + 1);
        }

        function getGridY(row) {
            return MARGIN + CELL * row;
        }

        function highlightGrid(/** @type {MouseEvent} */ ev) {
            if (/*TODO !playersTurn ||*/ timeEnd > 0) {
                return;
            }

            // get mouse position relative to the canvas
            let x = ev.clientX - canvRect.left;
            let y = ev.clientY - canvRect.top;

            // highlight the square's side
            highlightSide(x, y);
        }

        function highlightSide(x, y) {

            // clear previous highlighting
            for (let row of squares) {
                for (let square of row) {
                    square.highlight = null;
                }
            }

            // check each cell
            let rows = squares.length;
            let cols = squares[0].length;
            currentCells = [];
            OUTER: for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    if (squares[i][j].contains(x, y)) {

                        // highlight current
                        let side = squares[i][j].highlightSide(x, y);
                        if (side != null) {
                            currentCells.push({row: i, col: j});
                        }

                        // determine neighbour
                        let row = i, col = j, highlight, neighbour = true;
                        if (side == Side.LEFT && j > 0) {
                            col = j - 1;
                            highlight = Side.RIGHT;
                        } else if (side == Side.RIGHT && j < cols - 1) {
                            col = j + 1;
                            highlight = Side.LEFT;
                        } else if (side == Side.TOP && i > 0) {
                            row = i - 1;
                            highlight = Side.BOT;
                        } else if (side == Side.BOT && i < rows - 1) {
                            row = i + 1;
                            highlight = Side.TOP;
                        } else {
                            neighbour = false;
                        }

                        // highlight neighbour
                        if (neighbour) {
                            squares[row][col].highlight = highlight;
                            currentCells.push({row: row, col: col});
                        }

                        // no need to continue
                        break OUTER;
                    }
                }
            }
        }

        function newGame() {
            currentCells = [];
            scoreComp = 0;
            scorePlay = 0;
            timeEnd = 0;
            greenCounter = 0;
            winner = true;
            lines = new Array(GRID_SIZE * (GRID_SIZE + 1) * 2).fill(0);
            squareCounter = 0;
            loopTimer = 0;
            gameTimer = 0;
            stringTime = "00:00";
            gameNumber = parseInt(Math.random() * 11);
            generateLines();
            //console.log(gameNumber);


            // set up the squares
            squares = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                squares[i] = [];
                for (let j = 0; j < GRID_SIZE; j++) {
                    squares[i][j] = new Square(getGridX(j), getGridY(i), CELL, CELL, i, j);
                }
            }
        }

        function selectSide() {
            if (currentCells == null || currentCells.length == 0) {
                return;
            }

            // select the side(s)
            let filledSquare = false;
            for (let cell of currentCells) {
                if (squares[cell.row][cell.col].selectSide()) {
                    filledSquare = true;
                }
            }
            currentCells = [];
        }

        function Line(x0, y0, x1, y1, color, show) {
            this.x0 = x0;
            this.color = color;
            this.show = show;
            ctx.strokeStyle = color;
            ctx.beginPath();
            ctx.moveTo(x0, y0);
            ctx.lineTo(x1, y1);
            ctx.stroke();
        }

        // create the Square object constructor
        function Square(x, y, w, h, i, j) {
            this.w = w;
            this.h = h;
            this.bot = y + h;
            this.left = x;
            this.right = x + w;
            this.top = y;
            this.highlight = null;
            this.numSelected = 0;
            this.value = initialValues[gameNumber][squareCounter++];//parseInt(Math.random() * 4);
            this.i = i;
            this.j = j;
            this.color = COLOR_PLAY_LIT;
            //this.owner = null;
            this.sideBot = {selected: false, color: COLOR_BOARD};
            this.sideLeft = {selected: false, color: COLOR_BOARD};
            this.sideRight = {selected: false, color: COLOR_BOARD};
            this.sideTop = {selected: false, color: COLOR_BOARD};

            this.contains = function(x, y) {
                return x >= this.left && x < this.right && y >= this.top && y < this.bot;
            }

            this.clearLines = function() {
                this.numSelected = 0;
                drawLine(this.left, this.bot, this.right, this.bot, COLOR_BOARD);
                drawLine(this.left, this.top, this.left, this.bot, COLOR_BOARD);
                drawLine(this.right, this.top, this.right, this.bot, COLOR_BOARD);
                drawLine(this.left, this.top, this.right, this.top, COLOR_BOARD);
                this.sideBot = {selected: false, color: COLOR_BOARD};
                this.sideLeft = {selected: false, color: COLOR_BOARD};
                this.sideRight = {selected: false, color: COLOR_BOARD};
                this.sideTop = {selected: false, color: COLOR_BOARD};
            }

            this.drawFill = function() {
                // light background
                if (this.numSelected == this.value) {
                    ctx.fillStyle = getColorCopy(true);
                    if (this.color == COLOR_PLAY_LIT) {
                        greenCounter++;
                    }
                    this.color = GREEN;
                }
                else {
                    ctx.fillStyle = getColorCopy(false);
                    if (this.color == GREEN) {
                        greenCounter--;
                    }
                    this.color = COLOR_PLAY_LIT
                }
                
                ctx.fillRect(
                    this.left + STROKE, this.top + STROKE,
                    this.w - STROKE * 2, this.h - STROKE * 2
                );

                // owner text
                drawText(
                    getText(this.value, true),
                    this.left + this.w / 2,
                    this.top + this.h / 2,
                    getColor(false),
                    TEXT_SIZE_CELL
                );
            }

            this.drawSide = function(side, color) {
                switch(side) {
                    case Side.BOT:
                        drawLine(this.left, this.bot, this.right, this.bot, color);
                        break;
                    case Side.LEFT:
                        drawLine(this.left, this.top, this.left, this.bot, color);
                        break;
                    case Side.RIGHT:
                        drawLine(this.right, this.top, this.right, this.bot, color);
                        break;
                    case Side.TOP:
                        drawLine(this.left, this.top, this.right, this.top, color);
                        break;
                }
            }

            this.drawSides = function() {

                // highlighting
                /*if (this.highlight != null) {
                    this.drawSide(this.highlight, getColor(true));
                }*/

                // selected sides
                if (this.sideBot.selected) {
                    this.drawSide(Side.BOT, this.sideBot.color);
                }
                if (this.sideLeft.selected) {
                    this.drawSide(Side.LEFT, this.sideLeft.color);
                }
                if (this.sideRight.selected) {
                    this.drawSide(Side.RIGHT, this.sideRight.color);
                }
                if (this.sideTop.selected) {
                    this.drawSide(Side.TOP, this.sideTop.color);
                }
            }

            this.highlightSide = function(x, y) {

                // calculate the distances to each side
                let dBot = this.bot - y;
                let dLeft = x - this.left;
                let dRight = this.right - x;
                let dTop = y - this.top;

                // determine closest value
                let dClosest = Math.min(dBot, dLeft, dRight, dTop);

                // highlight the closest if not already selected
                if (dClosest == dBot) {
                    this.highlight = Side.BOT;
                } else if (dClosest == dLeft) {
                    this.highlight = Side.LEFT;
                } else if (dClosest == dRight) {
                    this.highlight = Side.RIGHT;
                } else if (dClosest == dTop) {
                    this.highlight = Side.TOP;
                }

                // return the highlighted side
                return this.highlight;
            }

            this.selectSide = function() {
                if (this.highlight == null) {
                    return;
                }

                // select the highlighted side
                switch (this.highlight) {
                    case Side.BOT:
                        this.sideBot.selected = true;
                        if (this.sideBot.color == COLOR_BOARD) {
                            this.numSelected++;
                            lines[this.j + GRID_SIZE + (GRID_SIZE * this.i)] = 1;
                            this.sideBot.color = COLOR_PLAY;
                        } else {
                            this.numSelected--;
                            lines[this.j + GRID_SIZE + (GRID_SIZE * this.i)] = 0;
                            this.sideBot.color = COLOR_BOARD;
                        }
                        break;
                    case Side.LEFT:
                        this.sideLeft.selected = true;
                        if (this.sideLeft.color == COLOR_BOARD) {
                            this.numSelected++;
                            lines[this.i + (GRID_SIZE * this.j) + 30] = 1;
                            this.sideLeft.color = COLOR_PLAY;
                        } else {
                            this.numSelected--;
                            lines[this.i + (GRID_SIZE * this.j) + 30] = 0;
                            this.sideLeft.color = COLOR_BOARD;
                        }
                        break;
                    case Side.RIGHT:
                        this.sideRight.selected = true;
                        if (this.sideRight.color == COLOR_BOARD) {
                            this.numSelected++;
                            lines[this.i + GRID_SIZE + (GRID_SIZE * this.j) + 30] = 1;
                            this.sideRight.color = COLOR_PLAY;
                        } else {
                            this.numSelected--;
                            lines[this.i + GRID_SIZE + (GRID_SIZE * this.j) + 30] = 0;
                            this.sideRight.color = COLOR_BOARD;
                        }
                        break;
                    case Side.TOP:
                        this.sideTop.selected = true;
                        if (this.sideTop.color == COLOR_BOARD) {
                            this.numSelected++;
                            lines[this.j + (GRID_SIZE * this.i)] = 1;
                            this.sideTop.color = COLOR_PLAY;
                        } else {
                            this.numSelected--;
                            lines[this.j + (GRID_SIZE * this.i)] = 0;
                            this.sideTop.color = COLOR_BOARD;
                        }
                        break;
                }
                this.highlight = null;

                if (this.numSelected == this.value) {


                    // filled
                    return true;
                }

                // not filled
                return false;
            }
        }
    </script>
    </div>
    &nbsp;
    &nbsp;
    &nbsp;
    &nbsp;
    &nbsp;
    &nbsp;
    &nbsp;
    &nbsp;
    &nbsp;
    &nbsp;
    &nbsp;
    &nbsp;
    &nbsp;
    &nbsp;
    &nbsp;
    &nbsp;
    <iframe style="border-radius:12px" src="https://open.spotify.com/embed/playlist/37i9dQZF1DWV7EzJMK2FUI?utm_source=generator&theme=0" width="45%" height="380" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture"></iframe>
</body>

</html>
